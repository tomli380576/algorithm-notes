[[{"l":"Algorithm Notes","p":["My notes for 122A, 122B and more.","Syntax Reference"]},{"l":"Textbooks","p":["UIUC textbook(Free to read)","CLRS","Algorithm Design by Kleinberg"]}],[{"l":"Ready-to-go LeetCode templates"},{"l":"Basic Utilities"},{"l":"Count character frequency"},{"l":"Whatever first search"},{"l":"Adjacency List","p":["Suppose the graph is stored as","This assumes min-heap (elements with numerically smaller priority is popped first). Negate the priority value if max-heap is needed."]},{"l":"Grid","p":["For simplicity we assume the grid is not empty and the first element is a list, i.e. an empty grid is [[]]. Validate the grid if necessary."]}],[{"l":"Introduction"}],[{"l":"Longest Common Subsequence","p":["Question. Given 2 strings X[1...m], Y[1...n] with arbitrary length, what is the longest common subsequence between them?","A common sequence satisfies the following:","They appear in the same order as they do in the original sequence","Doesn't need to be contiguous","Example: X = DCUT, Y = DUTC, then LCS(X, Y) = DUT"]},{"l":"1. Solve the Backtracking Problem First"},{"i":"11-function-signature","l":"1.1 Function signature","p":["Using the example above, let’s align the common letters:","We check 1 pair of characters at a time. Let’s use i for indexing X and j for indexing Y.","To “take” a pair, we advance the indices for both strings. So j is pointing at U right now:","That’s a mismatch, we need to skip. To \"skip\" a pair, we advance only 1 index, either i or j. Here the correct choice is i.","On the graph it might look obvious, but we won’t know that i is correct until the recursion result comes back. So from the algorithm's point of view it probably looks like this at current recursion level:","We don’t know what’s the length of LCS in the blacked out areas, so we continue until one of the strings becomes empty. Suppose we chose to skip i:","Now we know what the function should look like:","function LCS(i: int, j: int) - int","The return value is the length of the longest common subsequence."]},{"i":"12-base-cases","l":"1.2 Base cases","p":["If either string is empty, then their common subsequence is the empty string with 0 length.","If either i or j goes out of bounds, common subsequence is nothing \\implies length is also 0.","Therefore:"]},{"i":"13-recursive-cases","l":"1.3 Recursive Cases","p":["Let’s first consider what a choice is. A choice is whether to take or skip a character in the string.","There are only 2 valid choices at a time:","If the current character matches, then we definitely take from both","If the current character doesn’t match, then we must skip either i or j.","Now we consider how to make a choice. From 1.1 we observed that:","If we want to take the current pair, we advance both i and j.","If we skip, we try to advance i or j. Try both and we will take the better one with a max(...) call."]},{"i":"14-building-the-recurrence","l":"1.4 Building the recurrence","p":["Combining 1.2 and 1.3, we can write:","Convert to expressions:","In pseudocode:"]},{"i":"15-python-backtracking-lcs","l":"1.5 Python: Backtracking LCS","p":["We are making exactly 1 choice at each recursion level:","Take when X[i] == Y[j].","Skip when X[i] != Y[j]. Compute the results of skipping i and j, then take the better one.","Take is the only valid choice when X[i] == Y[j]."]},{"l":"2. Convert to Dynamic Programming"},{"i":"21-data-structure","l":"2.1 Data Structure","p":["LCS needs 2 arguments, so let’s use a 2D array. Let’s define:","dpTable = Array(shape=(m + 1, n + 1))","To get the result of a previous call, we can use dpTable[i, j]."]},{"i":"22-order-of-evaluation","l":"2.2 Order of Evaluation","p":["From the recurrence above, the \\text{LCS}(i, j) call requires:","\\text{LCS}(i+1, j + 1)","\\text{LCS}(i+1, j)","\\text{LCS}(i, j+1)","Since i + 1 > i and j + 1 > j, both i and j needs to go from high values to low values, which means we use reversed for loops for both. The nesting order doesn’t matter here because i and j don’t depend on each other.","In pseudocode:"]},{"l":"For 122A students","p":["Note that if we do the check direction backwards(last character to first), then the order of evaluation is reversed. This reversed order yields the original pseudocode from 122A.","Basically flip the scan line in this graph.","The backwards recurrence is:","In expressions:","Both i and j now need to go from low values to high values, hence the normal for loops."]},{"i":"3-python-dp-longest-common-subsequence","l":"3. Python: DP Longest Common Subsequence","p":["O(n^2) runtime from the nested for loop, O(n^2) space for the 2D array"]},{"l":"4. Recovering the Matches","p":["So far our solution correctly computes the length, but we don’t know which characters are in the final LCS. More formally, how do we record the matching pair of indices i, j as the loops in the DP solution progresses?"]},{"i":"41-recording-the-choices","l":"4.1 Recording the Choices","p":["We can use a technique called parent pointers. This technique will show up again in SSSP.","Recall from the recurrence that for all possible pairs of i,j, we always make a choice if we are not at the base case:","We can record the choices with a map, where the keys are the input parameters and the values are the choices:","We can add the choice-recording step:","Since we are iterating over all combinations of i and j, the lcsChoices map will have exactly m\\cdot n entries. Assuming we are not accounting for any additional memory overhead, the total space complexity remains O(mn)."]},{"i":"42-following-the-parent-pointers","l":"4.2 Following the parent pointers","p":["When we store the result lcsChoices[i, j] = [i + 1, j], we are saying that “the next best choice for \\text{LCS}(i,j) is (i+1, j)”.","The initial call for \\text{LCS} is i=1,j=1, so we start with this entry and follow the parent pointers until we hit the base case:","The while loop condition works because these loops from DP never go beyond m and n:","(m, n) will still be a key in lcsChoices, but none of its possible values, stored in lcsChoices[m, n], will be a key:","so we are guaranteed that this loop will stop."]},{"l":"Implementation Detail","p":["We are taking a shortcut here by assuming lcsChoices[i, j] is a valid key. This is valid in python because tuples are hash-able, but it might not be the case for other languages.","In that case we can always use a 2D array or a nested hash map and access by integer indices like lcsChoices[i][j]"]}],[{"l":"Optimal Binary Search Tree","p":["Given a sorted list of search items A[1...n] and a frequency list f[1...n], where f[i] is the number of times we will search for element A[i]."]}],[{"l":"Pretty printing","p":["Question. Given an array of N words and a maximum page width, what is the most optimal printing strategy that minimizes the total cost? Assume that any individual word can fit on one line.","the words we want to print neatly on a page","the maximum number of characters on a single line","a function that measures how \"bad\" a line is. The more empty spaces there are, the worse a line is. Let’s use x^3 here, where x is the number of trailing spaces.","We want to find:","a list of line break indices","the total cost after applying the line breaks","Depending on the variant of this question, sometimes the last line is free, which means we don’t calculate the cost of the final line.","To avoid weird indexing problems, let’s define a break at index i to mean putting \\tt words[i] on a new line."]},{"l":"1. Solve the Backtracking Problem"},{"i":"11-function-signature--base-case","l":"1.1 Function Signature & Base Case","p":["To keep track of how many words are remaining, we need an index j to indicate the last word that we need to place onto the paper. So the function looks like:","PrettyPrint(j: int) - int","and the initial call will be:","PrettyPrint(N)","There’s only 1 base case hereL: when there are no words, then there’s no cost, return 0.","PrettyPrint(0) = 0","In this case we are scanning from the last word to the first word, but reversing the scanning order also works. Flip the base case and initial call accordingly."]},{"i":"12-line-cost","l":"1.2 Line Cost","p":["From the problem inputs, we know that the cost of a line is given by:","Then number of empty spaces is:","num_empty_spaces = page_width - sentence_length","For the length of the sentence, we also need to count the number of spaces between the words.","Let’s define a function LineCost(i, j).","i is the index of the first word on this line","j is the index of the last word on this line","Both i and j are indices for the \\texttt{words} array","This is a bit different from the previous backtracking problems. We are incorporating the find valid choices step into this cost function by using \\infty as 1 of the costs.","To compute the number of empty spaces, lets define:","where i, j are the indices of the original words array. We can see that computing \\text{Extras} will take O(n) time where n is the number of words.","Now we can translate \\text{LineCost} into expressions:","So \\text{LineCost} also runs in O(n) time."]},{"i":"13-recursive-cases","l":"1.3 Recursive Cases","p":["This falls under the Best Solution case with the FindNext strategy, so we need:","Choices","Every index before the current index is a choice. We can place a line break at any of them.","The \"valid\" choice part is handled by the \\text{LineCost} function.","If the choice is not valid, \\text{LineCost} will return \\infty and it’s definitely not going to be selected.","How to make a choice","To make a choice, we go to the \"next\" word we want to place. We can either go from the end or go from the beginning.","If we go from the end j=n, the next one is j-1.","If we go from the beginning j=1, the next one is j+1.","Since we want to minimize the total cost, we will also need a min(...) call"]},{"i":"14-recurrence--pseudocode","l":"1.4 Recurrence & Pseudocode","p":["Combining 1.1 ~ 1.3, the recurrence is:","In expressions:","Convert to pseudocode:","Don’t forget i\\red{-1} in the recursive call, otherwise some words are considered multiple times."]},{"l":"1.5 Python. Backtracking Pretty Printing","p":["At each recursion level, we “choose” a line break","All indices before the current j is a “valid” choice","We take the min from all the choice results","Make sure you feel comfortable with the brute force solution before moving on to section 2."]},{"l":"2. Convert to Dynamic Programming"},{"i":"21-order-of-evaluation--data-structure","l":"2.1 Order of Evaluation & Data Structure","p":["From the recurrence:","Unwrapping the \\min call shows that \\text{PrettyPrint}(j) needs: @Hint Plug in possible values of i.","\\text{PrettyPrint}(0)","\\text{PrettyPrint}(1)","…","\\text{PrettyPrint}(j-1)","We need to compute the function results of the smaller j’s first, thus the order of evaluation for j goes in ascending order.","The function only needs 1 parameter, so we can use a 1D array."]},{"i":"22-pseudocode","l":"2.2 Pseudocode","p":["Time complexity is O(n^3) and space complexity is O(n)."]},{"i":"-3-memoizing-linecost-and-extras","l":"❖ 3. Memoizing LineCost and Extras","p":["Calling \\text{LineCost} inside the nested for loops can be expensive, so we should isolate that from the main memoization loop.","\\text{LineCost} needs 2 parameters, so we can use a 2D array. But directly going through all combinations of i, j doesn’t really help because that’s still O(n^3)","So we need to somehow use previous results to make the evaluation lineCost[i, j] O(1).","Observe that the actual work happens inside \\text{Extras}(i, j). Instead of recomputing the total number of characters every time we increase j, we can build on top of the previous result like this:","We can assume the \\text{len} function for finding the number of characters is O(1) because the work is done before the \\text{PrettyPrint} routine starts.","The base case is a single word:","Extras(i, i) = page_width - len(words[i])","\\text{Extras}(i, j) requires \\text{Extras}(i, j-1), so the order of evaluation goes in ascending order:","Now memoizing \\text{Extras} becomes O(n^2)."]},{"l":"4. Putting everything together","p":["The recurrences are:","Line cost itself isn’t really a recurrence but it’s important:","Runtime is O(n^2) with O(n^2) space."]},{"i":"5-python-dp-pretty-printing","l":"5. Python: DP Pretty Printing"}],[{"i":"rod-cutting-122a","l":"Rod Cutting (122A)","p":["Question. Given a rod with length n and an array of prices of each length p_i, how can we cut the rod to make the most amount of money?","Length of the rod","List of prices for rod length from i=1 to i=n. For example: p_1 = 1, p_2 = 3, p_3 = 5, \\dots","We want to find:","revenue: int, the max revenue possible from rod of length n","cuts: Listint, cut strategy to make the max revenue. Element at index i represents the length to cut at step i.","Let's call this function CutRod(n). Since the price array p is fixed, we will omit p from the call signature from now on."]},{"l":"Solve the Backtracking Problem"},{"l":"Base Cases","p":["Recall from basic recursion that the bases cases are the subproblems that we can immediately solve. We know how to solve:","n = 0, we have no rod, so we make no money.","CutRod(0) = 0","n = 1, we have the shortest rod that we can possibly sell, so the profit is exactly p_1.","CutRod(1) = p[1]"]},{"l":"Recursive Cases","p":["We first consider what a choice is and how to make a choice.","A choice is the length we can cut from the current rod.","So the set of choices is from 1 to n because they are all valid. To make a choice, we decrease the rod length by our chosen length and add that price to the current total price.","We also want to take the best choice, so we need a max call:","From the all the possible cuts, take the one that gives the maximum profit"]},{"l":"The Recurrence","p":["This problem falls under the best solution case because we want the maximum amount of money.","Translate it into expressions:"]},{"l":"Backtracking Implementation","p":["In short, the components of this recursive backtracking problem are:","Sequence of decisions- We need to make a sequence of cuts.","Make 1 decision at a time- We make 1 cut at every recursive call.","A choice here is the length to cut. All lengths from 1 to the remaining length is valid","To make a choice, decrease the remaining length.","Satisfy all the constraints- We can’t cut more rod than we currently have.","Make sure you are comfortable with the brute force approach before moving to DP conversion."]},{"l":"Convert to Dynamic Programming"},{"l":"Data structure","p":["Observe that every call requires only 1 argument rodLen, so we can use an 1D array to store our results. Let’s define:","To get the result of a previous call, we can use dpTable[rodLen].","This dpTable[rodLen] corresponds to the brute force result CutRod(rodLen).","If you really wish to make this pretty, name the DP table cutRod.","The final result should be in dpTable[maxRodLen] where maxRodLen is the initial parameter (represents the full rod length)"]},{"l":"Order of evaluation","p":["The function depends on other recursive calls in this way:","Equivalently from the recurrence:","So we need to evaluate all of \\{\\text{CutRod}(n-i)\\}_{1\\leqslant i \\leqslant n} first before we can know the result of CutRod(n). Since n-i < n, the first thing that goes into the table is CutRod(0) and we evaluate in ascending order."]},{"l":"Build the DP Table"},{"l":"Reconstructing the Solution","p":["The pseudocode above only finds the optimal profit, but it doesn't tell us how to actually cut the rod. We can record the cut by adding the following"]},{"l":"DP Implementation"},{"l":"Runtime Analysis","p":["We can see that this is the classic nested for loop:","So the runtime is O(n^2) and memory is O(n) from 1D Array."]},{"l":"Proof. Optimal Substructure","p":["State the given:","Given \\text{OPT}(n) for rod of length n with first cut i","\\text{OPT}(n)=p_i + a, where a is the amount of money made on rod of length n-i","Prove: a is the optimal solution for rod of length n-i, or a = \\text{OPT}(n-i)","Assume a is not optimal for rod of length n-i","Let rev(t) denote the revenue from strategy t","Then there exists another strategy b such that rev(b) > rev(a)","We already assumed OPT is the best solution, then a better one cannot exist.","Contradiction with given. Therefore a is optimal for n-i.","The key point is that the optimal solution to the subproblem is unique."]}],[{"l":"The Only Graph Traversal Algorithm","p":["Question. How to visit every vertex exactly once in a graph?"]},{"l":"Whatever First Search","p":["To keep track of which vertices we have seen, we use 2 STATUS values:","NEW: Never seen before.","SEEN: Processed exactly once.","Let T be the generic type name. We will make up an imaginary data structure called a BagT. It has 3 methods:","put(element: T) puts an element in the bag.","popFirst() - T returns whatever is the \"first\" thing in the bag and removes it.","isEmpty() - bool returns whether the bag is empty or not.","Then the pseudocode for whatever first search is:","Here process(u) is just a blackbox subroutine. We can do anything inside process(u) as long as we don’t change the vertex status."]},{"l":"Important Variants","p":["Best First Search","Breadth First Search","By changing the bag's behavior of popFirst() and put(element), we get the familiar search algorithms:","C++ also has std::dequeT","Depth First Search. DFS is usually implemented with recursion allowing cycle detection.","deque.pop() gives us DFS","deque.popleft() gives us BFS","For priority queue we could use heapq on a regular list [].","In python, we can easily swap between DFS and BFS by using collections.deque.","popFirst() pops from the end","popFirst() pops from the front","popFirst() pops the element with highest priority in O(\\log n) time.","put(element) appends to the end","put(element) appends with a priority value in O(\\log n) time","Use heappush and heappop to append and pop from the priority queue. See its use in Dijkstra's Algorithm.","We can represent NEW and SEEN with a set"]},{"l":"Python","p":["The WhateverFirstSearch_Connected function implements this.","This version of Whatever First Search assumes that the start can actually reach every other vertex in the graph. This works if we know the graph is connected.","To handle disconnected graphs we need to make the following modifications."]},{"i":"whatever-first-searchall","l":"Whatever First Search–All","p":["For each vertex in G, if we’ve never visited this vertex before, visit everything that we can reach from this vertex.","We will make a small wrapper.","Changing the bag's behavior on popFirst() will result in the same variants, but now they can handle disconnected graphs."]},{"l":"Python","p":["The WhateverFirstSearch_All function implements this."]}],[{"i":"breadth-first-search-122a","l":"Breadth First Search (122A)"},{"l":"Basics","p":["We can implement BFS from whatever first search by using a Queue.","The 122A version checks whether the adjacent vertex v is visited. The WFS version checks if the current vertex u is new."]},{"l":"Python"},{"i":"with-time-full-122a-version","l":"With time (full 122A Version)","p":["We can also record \"when\" a vertex is visited. Each time we see a new vertex, we increment the \"time\". The discover time of a vertex starts with \\infin."]},{"i":"observing-bfss-behavior","l":"Observing BFS’s Behavior","p":["We can observe how each ‘layer’ of the graph is being visited by BFS by adding a special token.","The changes are highlighted. Everything else is the same.","while queue has at least 1 vertex does not mean queue.size 0. The special token is not a vertex."]},{"l":"Python"},{"l":"Examples"},{"i":"ex1","l":"EX.1","p":["Given this graph, and we start at vertex \\tt{S}","Starting from \\tt S, we can see that all the red nodes \\tt{\\red{ACG}} are 1 edge away, and the purple nodes \\tt\\purple{BDEFH} are 2 edges away."]},{"i":"ex2","l":"EX.2","p":["If we start at \\tt{\\color{darkorange}A}, then the graph will be visited in this order: \\tt{{\\color{darkorange} A}\\to \\red {BCE}\\to\\purple D}","Vertices with the same color could be visited in any order depending on the order of insertion, but the overall order is Orange → Red → Purple.","Running the code from 2.3:"]}],[{"i":"recursive-depth-first-search-122a","l":"Recursive Depth First Search (122A)"},{"l":"Vertex Status","p":["Similar to whatever first search, we assign each vertex a \\purple{\\texttt{STATUS}}.","\\texttt{NEW}: literally never seen before, all vertices start with this status","\\texttt{ACTIVE}: seen before, but the adjacent vertices are not done processing yet","\\texttt{FINISHED}: the vertex is seen and all its children are done processing"]},{"l":"Pseudocode"},{"i":"python-basic-dfs","l":"Python: Basic DFS"},{"l":"Comparison with stack based Whatever First Search","p":["The recursive version replaces stack.put(v) with the recursive call DFS_Visit(v).","while stack is not empty is the same as coming back to the initial call (empty call stack).","Every time DFS_Visit(v) is called in the main routine, a new call stack is initialized. WFS does this by calling the stack constructor."]},{"l":"Runtime Analysis","p":["For a graph with V vertices and E edges, we call the DFS_Visit(v) function V times in the main routine. The total number of recursive calls inside DFS_Visit(v) is E times because we will traverse each edge exactly once, so E times for the entire graph.","Therefore the total runtime is O(V+E)."]},{"l":"Classifying Edges and Cycle Detection","p":["There are 4 possible types of edges:","More specifically:","Source: Prof Bai’s 122A slides. Gray = Active, White = New, Black = Finished"]},{"l":"Edge Interpretations","p":["At least one back edge is found \\iff the graph has a cycle. So Directed Acyclic Graphs (Like a DP dependency graph) cannot have a back edge.","Found at least 1 cross or forward edge \\implies the graph is directed","Read more here"]},{"i":"python-dfs-with-edge-classification","l":"Python: DFS with edge classification","p":["Right now it only finds back and tree edges correctly, still figuring out how to find forward and cross edges"]}],[{"l":"Huffman Encoding"}],[{"i":"max-sub-array-122a","l":"Max Sub-array (122A)"},{"l":"Problem Statement","p":["Question. Given a 1-dimensional array, find a contiguous sub-array with the largest sum","the array we select from"]},{"l":"Dividing the problem","p":["The maximum sub-array can show up in 3 places:","The left half of A","The right half of A","The middle section of A","The left half and right half does not overlap. Overlap is handled by the middle section."]},{"l":"Base Cases","p":["There are 2 base cases:","A is empty, so we return 0 for the sum of nothing.","A has exactly 1 element, so we return that element A[1]"]},{"l":"Recursive Cases","p":["To avoid passing the main array around on the stack, we can use the 2 pointer approach with low and high pointers. The recursive calls will look like:","where the 2 recursive calls correspond to the left and right half of A."]},{"l":"The Max Middle Sum","p":["The name is kinda misleading, but we want to consider this:","Question. What contiguous sub-array, that might contain the middle element, gives us the maximum sum?","So we check both ways. Take the element if it keeps the array contiguous AND increases the sum.","Check from mid - 1 to low","Example. Left Half","Then check from mid to high","Example. Right Half","The best middle sum could also involve both the left and right half, for example if all elements are positive. So we take the max(...) of all:"]},{"l":"Combining the Results","p":["Now we know what’s max in left, right, and middle, we just take the max."]},{"l":"Pseudocode"},{"i":"python-max-subarray","l":"Python: Max Subarray","p":["Go faster: Max Subarray: Kadane’s Algorithm (WIP)"]}],[{"i":"merge-sort-122a","l":"Merge Sort (122A)","p":["Given A[1...n]: Listnumber, the idea of merge sort is:"]},{"l":"Dividing the Problem","p":["We need to split the array in half. Let low and high denote the current starting and ending indices of the array (inclusive). Then we can find the middle index mid by:","Note that this could cause integer overflow when low and high are large. A better way would be:","And the recursive calls are:"]},{"l":"Base Cases","p":["This is where we actually do the comparison. We have 2 base cases:","The array is empty or has 1 element, then we do nothing.","The array has exactly 2 elements, then we directly compare.","This case could be implicitly handled by merging two 1–element arrays, so no need to explicitly implement this case."]},{"l":"Merge 2 sorted Arrays","p":["Now that the recursion has sorted the left and right array for us, we need to merge them together. We can use the 2 pointer approach here.","Let l and r be the traversing pointers in the left & right sorted arrays respectively.","It’s probably easier to consider merging with 2 separate arrays first.","Translate into expressions: (Assuming we are sorting in ascending order. Flip < to > if reversed.)","The 2nd and 3rd while loops are safe because at most 1 of them will run, and the loop that runs corresponds to the array that has all its remaining elements \\geqslant the last element in output.","We can also see that this is a linear scan, so the runtime is O(n)."]},{"l":"Implementation Detail","p":["In actual implementation, don’t actually slice the main array into L and R because passing arrays on the stack is expensive. Instead, pass in an extra parameter mid to indicate where the left half ends, then merge with the same 2 pointer approach.","At the end, instead of returning output, replace all elements in the parameter array with output. This requires the main array to be passed as a reference so it may be different depending on the language."]},{"l":"Code"}],[{"i":"quick-select-122b","l":"Quick Select (122B)","p":["Question. Given an unsorted A[1...N]: Listnumber and a positive integer k, 1 = k = N, how do we find the k-th smallest element of A in O(n) time?","For example, A = [3,2,1,5,6,4], k = 2 gives us 2."]},{"l":"One Armed Quick Select","p":["The idea is similar to quick sort. Partition A by some pivot, then recursively search the left and right half with respect to the pivot.","Let the pivot value be p, pivot index be pivot_index. Recall that A[i]< p if i pivot_index, and A[i] = p if i = pivot_index"]},{"l":"Example Walkthrough","p":["For A = [3,2,1,5,6,4], k = 2, we have:"]},{"l":"Decide which half to search","p":["If p is the pivot value, then after partition(), the array A looks like this:","Notice that there's a chunk of p next to each other in the middle. Recall that the idea is to recursively search the left and right half. If k len(left), then the k th smallest is in left, so we just do the recursive call on left.","If is in the right half,"]}],[{"i":"quick-sort-122a","l":"Quick Sort (122A)","p":["The idea of quick sort is:"]},{"l":"Base Case","p":["When A has 1 or 0 elements, we do nothing."]},{"l":"Partition","p":["↑ This partitioning step is doing most of the work.","Unlike merge sort, after left & right partitions are sorted, the merging step is already done.","Similar to how we considered merge(), it’s easier to think about if we use extra space.","(Change < to other predicates depending on the sorting order)","This is also a linear scan, so the runtime is O(n)."]},{"l":"Choosing the Pivot","p":["There are a lot of ways for choosing pivots:","Always pick first","Always pick last","Choose randomly","Somehow pick out the true median of A(important for quick select)","Source"]},{"l":"Pseudocode"},{"l":"Python"}],[{"i":"randomized-quick-select-122b","l":"Randomized Quick Select (122B)","p":["Type of Divide & Conquer: Pivot"]}],[{"i":"tower-of-hanoi-36b","l":"Tower of Hanoi (36B)","p":["Question. Given 3 pegs and n disks, how can we move all the disks from src to dest such that larger disks cannot stack on top of smaller disks?","number of disks. This implies we have disk from radius 1 to n","3 pegs that we can puts disks on. src initially has the disks [1\\dots n] on it. dest, temp will be empty initially."]},{"l":"Reducing the problem","p":["Source: Erickson Text","We can observe that:","The largest disk has to go on the \\tt{dest} peg first before everything else.","To do so, we need to move everything else to the \\tt{temp} peg first. Now \\tt{src} only has the largest disk and \\tt{dest} is empty ⇒ so we can directly move.","Let’s consider a simple case with only 2 disks.","We do this 4-step process for any number of disks, except that 2 is the n-th disk and disk 1\\sim n is in the position of 1."]},{"l":"Pseudocode"},{"i":"python-tower-of-hanoi","l":"Python: Tower of Hanoi"}],[{"l":"Pseudocode Syntax Reference"},{"l":"Basics","p":["Math operators are used the same as they are in formal mathematical writing.","- indicates a return type. Only used for function declarations.","If nothing is returned, this symbol is unused.","Any kind of indexing, range, interval is inclusive unless explicitly stated.","Example: A[1...N]: Listnumber means the list A has N elements and can be indexed by 1, 2, 3, ... N.","Angle brackets T indicate the use of type parameters. For example, ListVertex means elements of this list are vertices."]},{"l":"Examples","p":["In this pseudocode:","Array A can be indexed by integers in [1, n]","mid was declared and assigned the value floor(n / 2)","floor, Merge are function calls","Returns nothing","Here we have an global constant prices = [...]. The function returns a number. int or float are explicitly stated when it is important (e.g. if the function returns an index, it must be an int)."]},{"l":"Data Structure Initialization","p":["Any object will be created on the heap through its constructor and are passed around by reference. (anything other than numbers, booleans, and strings)"]},{"l":"Multi-dimensional Arrays","p":["Let’s use this syntax to state each dimension's size of the array:","For example:","This means B can be indexed by:","1 through 5 on the 1st axis","1 through 6 on the 2nd axis."]}]]