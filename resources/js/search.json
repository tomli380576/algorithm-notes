[[{"l":"Algorithm Notes","p":["My notes for 122A, 122B and more.","Syntax Reference"]},{"l":"Textbooks","p":["UIUC textbook(Free to read)","CLRS","Algorithm Design by Kleinberg","The logo is generated here.","Fetching last updated date..."]}],[{"l":"Ready-to-go LeetCode templates"},{"l":"Basic Utilities"},{"l":"Count character frequency"},{"l":"Binary Search","p":["Returns -1 if target is not found"]},{"l":"Whatever first search"},{"l":"Adjacency List","p":["Suppose the graph is stored as","This assumes min-heap (elements with numerically smaller priority is popped first). Negate the priority value if max-heap is needed."]},{"l":"Grid","p":["For simplicity we assume the grid is not empty and the first element is a list, i.e. an empty grid is [[]]. Validate the grid if necessary."]}],[{"l":"Geometric Series Shortcuts","p":["For a constant \\alpha \\in \\R_{>0} and some upper bound k(doesn't have to be an integer when we are dealing with big Os), we have this nice shortcut to get the upper bound:"]},{"l":"Examples","p":["Expand, the number of levels is i = \\log_2n"]}],[{"l":"Max Sub-array (122A)"},{"l":"Problem Statement","p":["Question. Given a 1-dimensional array, find a contiguous sub-array with the largest sum","the array we select from"]},{"l":"Dividing the problem","p":["The maximum sub-array can show up in 3 places:","The left half of A","The right half of A","The middle section of A","The left half and right half does not overlap. Overlap is handled by the middle section."]},{"l":"Base Cases","p":["There are 2 base cases:","A is empty, so we return 0 for the sum of nothing.","A has exactly 1 element, so we return that element A[1]"]},{"l":"Recursive Cases","p":["To avoid passing the main array around on the stack, we can use the 2 pointer approach with low and high pointers. The recursive calls will look like:","where the 2 recursive calls correspond to the left and right half of A."]},{"l":"The Max Middle Sum","p":["The name is kinda misleading, but we want to consider this:","Question. What contiguous sub-array, that might contain the middle element, gives us the maximum sum?","So we check both ways. Take the element if it keeps the array contiguous AND increases the sum.","Check from mid - 1 to low","Example. Left Half","Then check from mid to high","Example. Right Half","The best middle sum could also involve both the left and right half, for example if all elements are positive. So we take the max(...) of all:"]},{"l":"Combining the Results","p":["Now we know what’s max in left, right, and middle, we just take the max."]},{"l":"Pseudocode"},{"l":"Python: Max Subarray","p":["Go faster: Max Subarray: Kadane’s Algorithm (WIP)"]}],[{"l":"Merge Sort (122A)","p":["Given A[1...n]: Listnumber, the idea of merge sort is:"]},{"l":"Dividing the Problem","p":["We need to split the array in half. Let low and high denote the current starting and ending indices of the array (inclusive). Then we can find the middle index mid by:","Note that this could cause integer overflow when low and high are large. A better way would be:","And the recursive calls are:"]},{"l":"Base Cases","p":["This is where we actually do the comparison. We have 2 base cases:","The array is empty or has 1 element, then we do nothing.","The array has exactly 2 elements, then we directly compare.","This case could be implicitly handled by merging two 1–element arrays, so no need to explicitly implement this case."]},{"l":"Merge 2 sorted Arrays","p":["Now that the recursion has sorted the left and right array for us, we need to merge them together. We can use the 2 pointer approach here.","Let l and r be the traversing pointers in the left & right sorted arrays respectively.","It’s probably easier to consider merging with 2 separate arrays first.","Translate into expressions: (Assuming we are sorting in ascending order. Flip < to > if reversed.)","The 2nd and 3rd while loops are safe because at most 1 of them will run, and the loop that runs corresponds to the array that has all its remaining elements \\geqslant the last element in output.","We can also see that this is a linear scan, so the runtime is O(n)."]},{"l":"Implementation Detail","p":["In actual implementation, don’t actually slice the main array into L and R because passing arrays on the stack is expensive. Instead, pass in an extra parameter mid to indicate where the left half ends, then merge with the same 2 pointer approach.","At the end, instead of returning output, replace all elements in the parameter array with output. This requires the main array to be passed as a reference so it may be different depending on the language."]},{"l":"Code"}],[{"l":"Quick Select (122B)","p":["Question. Given an unsorted A[1...N]: Listnumber and a positive integer k, 1 = k = N, how do we find the k-th smallest element of A in O(n) time?","For example, A = [3,2,1,5,6,4], k = 2 gives us 2."]},{"l":"One Armed Quick Select","p":["The idea is similar to quick sort. Partition A by some pivot, then recursively search the left and right half with respect to the pivot.","Let the pivot value be p, pivot index be pivot_index. Recall that A[i]< p if i pivot_index, and A[i] = p if i = pivot_index"]},{"l":"Example Walkthrough","p":["For A = [3,2,1,5,6,4], k = 2, we have:"]},{"l":"Decide which half to search","p":["If p is the pivot value, then after partition(), the array A looks like this:","Notice that there's a chunk of p next to each other in the middle. Recall that the idea is to recursively search the left and right half. If k len(left), then the k th smallest is in left, so we just do the recursive call on left.","If is in the right half,"]}],[{"l":"Quick Sort (122A)","p":["The idea of quick sort is:"]},{"l":"Base Case","p":["When A has 1 or 0 elements, we do nothing."]},{"l":"Partition","p":["↑ This partitioning step is doing most of the work.","Unlike merge sort, after left & right partitions are sorted, the merging step is already done.","Similar to how we considered merge(), it’s easier to think about if we use extra space.","(Change < to other predicates depending on the sorting order)","This is also a linear scan, so the runtime is O(n)."]},{"l":"Choosing the Pivot","p":["There are a lot of ways for choosing pivots:","Always pick first","Always pick last","Choose randomly","Somehow pick out the true median of A(important for quick select)","Source"]},{"l":"Pseudocode"},{"l":"Python"}],[{"l":"Randomized Quick Select (122B)","p":["Type of Divide & Conquer: Pivot"]}],[{"l":"Tower of Hanoi (36B)","p":["Question. Given 3 pegs and n disks, how can we move all the disks from src to dest such that larger disks cannot stack on top of smaller disks?","number of disks. This implies we have disk from radius 1 to n","3 pegs that we can puts disks on. src initially has the disks [1\\dots n] on it. dest, temp will be empty initially."]},{"l":"Reducing the problem","p":["Source: Erickson Text","We can observe that:","The largest disk has to go on the \\tt{dest} peg first before everything else.","To do so, we need to move everything else to the \\tt{temp} peg first. Now \\tt{src} only has the largest disk and \\tt{dest} is empty ⇒ so we can directly move.","Let’s consider a simple case with only 2 disks.","We do this 4-step process for any number of disks, except that 2 is the n-th disk and disk 1\\sim n is in the position of 1."]},{"l":"Pseudocode"},{"l":"Python: Tower of Hanoi"}],[{"l":"Introduction"},{"l":"General DP Formulation","p":["Typically a DP problem involves searching for a sequence of decisions that arrives at a maximum or minimum value. Let's define:","A \"stage\" of the problem. When t=N, we have reached the end of the problem. This is usually the variable representing time / planning horizon, but not necessarily","State at stage t; S is the space of all possible states","Action at stage t; A is the space of all possible actions","Reward function if we take action a_t at state s_t","Reward if we end on state s_N. This is the cost/reward of our base case, a subproblem that we can immediately solve without recursion. If we reach s_N, we have no possible actions.","Now the optimality equation/ value function/ objective recurrence is:"]},{"l":"Examples"},{"l":"Rod Cutting","p":["For a rod of length N,","In this case, the remaining length of the rod is the state s_t, and the number of units of rod to cut is the action a_t. We immediately encounter the first exception of the definition of stage t. The only thing that's constant is the initial length of the rod, or the maximum length we can cut in 1 go. Therefore the stage is technically time, but it ranges from 1...N since the max number of cuts we can make is just the total length N(just cut 1 unit at a time).","The rest of the variables are straightforward to find: the revenue of a cut is the reward function; final reward is either 0 or p_1, and s_{n+1} is the new length after the cut.","Let's list each component:","Stage is the \"time\" elapsed or the total number of cuts we have made","State is the length of the remaining rod","Action the the possible cuts we can make. Ranges from 1 to s_t","Reward is the revenue of the cut","Base cases, s_N = 0 or s_N = 1 which means R(0) = 0, R(1) = p_1","optimality equation is:"]},{"l":"Edit Distance","p":["For strings A[1...n], B[1...m]"]}],[{"l":"Rod Cutting (122A)","p":["Question. Given a rod with length n and an array of prices of each length p_i, how can we cut the rod to make the most amount of money?","Length of the rod","List of prices for rod length from i=1 to i=n. For example: p_1 = 1, p_2 = 3, p_3 = 5, \\dots","We want to find:","revenue: int, the max revenue possible from rod of length n","cuts: Listint, cut strategy to make the max revenue. Element at index i represents the length to cut at step i.","Let's call this function CutRod(n). Since the price array p is fixed, we will omit p from the call signature from now on."]},{"l":"Solve the Backtracking Problem"},{"l":"Base Cases","p":["Recall from basic recursion that the bases cases are the sub-problems that we can immediately solve. We know how to solve:","n = 0, we have no rod, so we make no money.","CutRod(0) = 0","n = 1, we have the shortest rod that we can possibly sell, so the profit is exactly p_1.","CutRod(1) = p[1]"]},{"l":"Recursive Cases","p":["We first consider what a choice is and how to make a choice.","A choice is the length we can cut from the current rod.","So the set of choices is from 1 to n because they are all valid. To make a choice, we decrease the rod length by our chosen length and add that price to the current total price.","We also want to take the best choice, so we need a max call:","From the all the possible cuts, take the one that gives the maximum profit"]},{"l":"The Recurrence","p":["This problem falls under the best solution case because we want the maximum amount of money.","Translate it into expressions:"]},{"l":"Backtracking Implementation","p":["In short, the components of this recursive backtracking problem are:","Sequence of decisions- We need to make a sequence of cuts.","Make 1 decision at a time- We make 1 cut at every recursive call.","A choice here is the length to cut. All lengths from 1 to the remaining length is valid","To make a choice, decrease the remaining length.","Satisfy all the constraints- We can’t cut more rod than we currently have.","Make sure you are comfortable with the brute force approach before moving to DP conversion."]},{"l":"Convert to Dynamic Programming"},{"l":"Data structure","p":["Observe that every call requires only 1 argument rodLen, so we can use an 1D array to store our results. Let’s define:","To get the result of a previous call, we can use dpTable[rodLen].","This dpTable[rodLen] corresponds to the brute force result CutRod(rodLen).","If you really wish to make this pretty, name the DP table cutRod.","The final result should be in dpTable[maxRodLen] where maxRodLen is the initial parameter (represents the full rod length)"]},{"l":"Order of evaluation","p":["The function depends on other recursive calls in this way:","Equivalently from the recurrence:","So we need to evaluate all of \\{\\text{CutRod}(n-i)\\}_{1\\leqslant i \\leqslant n} first before we can know the result of CutRod(n). Since n-i < n, the first thing that goes into the table is CutRod(0) and we evaluate in ascending order."]},{"l":"Build the DP Table"},{"l":"Reconstructing the Solution","p":["The pseudocode above only finds the optimal profit, but it doesn't tell us how to actually cut the rod. We can record the cut by adding the following"]},{"l":"DP Implementation"},{"l":"Runtime Analysis","p":["We can see that this is the classic nested for loop:","So the runtime is O(n^2) and memory is O(n) from 1D Array."]},{"l":"Proof. Optimal Substructure","p":["Given \\text{OPT}(n) for rod of length n with first cut i, we have \\text{OPT}(n)=p_i + a, where a is the amount of money made on rod of length n-i.","We want to prove that a is the optimal solution for rod of length n-i, or a = \\text{OPT}(n-i).","Assume a is not optimal for rod of length n-i. Let rev(t) denote the revenue from strategy t, then there exists another strategy b such that rev(b) > rev(a).","We already assumed OPT is the best solution, then a better one cannot exist. Therefore we found a contradiction with given; a is optimal for n-i.","The key point is that the optimal solution to the subproblem is unique."]}],[{"l":"Longest Common Subsequence","p":["Question. Given 2 strings X[1...m], Y[1...n], what is the longest common subsequence between them? A common sequence satisfies the following:","They appear in the same order as they do in the original sequence","Doesn't need to be contiguous","Example: X = DCUT, Y = DUTC, then LCS(X, Y) = DUT"]},{"l":"1. Solve the Backtracking Problem First"},{"l":"1.1 Function signature","p":["Using the example above, let’s align the common letters:","We check 1 pair of characters at a time. Let’s use i for indexing X and j for indexing Y.","To “take” a pair, we advance the indices for both strings. So j is pointing at U right now:","That’s a mismatch, we need to skip. To \"skip\" a pair, we advance only 1 index, either i or j. Here the correct choice is i.","On the graph it might look obvious, but we won’t know that i is correct until the recursion result comes back. So from the algorithm's point of view it probably looks like this at current recursion level:","We don’t know what’s the length of LCS in the blacked out areas, so we continue until one of the strings becomes empty. Suppose we chose to skip i:","Now we know what the function should look like:","function LCS(i: int, j: int) - int","The return value is the length of the longest common subsequence."]},{"l":"1.2 Base cases","p":["If either string is empty, then their common subsequence is the empty string with 0 length.","If either i or j goes out of bounds, common subsequence is nothing \\implies length is also 0.","Therefore:"]},{"l":"1.3 Recursive Cases","p":["Let’s first consider what a choice is. A choice is whether to take or skip a character in the string.","There are only 2 valid choices at a time:","If the current character matches, then we definitely take from both","If the current character doesn’t match, then we must skip either i or j.","Now we consider how to make a choice. From 1.1 we observed that:","If we want to take the current pair, we advance both i and j.","If we skip, we try to advance i or j. Try both and we will take the better one with a max(...) call."]},{"l":"1.4 Building the recurrence","p":["Combining 1.2 and 1.3, we can write:","Convert to expressions:","In pseudocode:"]},{"l":"1.5 Python: Backtracking LCS","p":["We are making exactly 1 choice at each recursion level:","Take when X[i] == Y[j].","Skip when X[i] != Y[j]. Compute the results of skipping i and j, then take the better one.","Take is the only valid choice when X[i] == Y[j]."]},{"l":"2. Convert to Dynamic Programming"},{"l":"2.1 Data Structure","p":["LCS needs 2 arguments, so let’s use a 2D array. Let’s define:","dpTable = Array(shape=(m + 1, n + 1))","To get the result of a previous call, we can use dpTable[i, j]."]},{"l":"2.2 Order of Evaluation","p":["From the recurrence above, the \\text{LCS}(i, j) call requires:","\\text{LCS}(i+1, j + 1)","\\text{LCS}(i+1, j)","\\text{LCS}(i, j+1)","Since i + 1 > i and j + 1 > j, both i and j needs to go from high values to low values, which means we use reversed for loops for both. The nesting order doesn’t matter here because i and j don’t depend on each other.","In pseudocode:"]},{"l":"For 122A students","p":["Note that if we do the check direction backwards(last character to first), then the order of evaluation is reversed. This reversed order yields the original pseudocode from 122A.","Basically flip the scan line in this graph.","The backwards recurrence is:","In expressions:","Both i and j now need to go from low values to high values, hence the normal for loops."]},{"l":"3. Python: DP Longest Common Subsequence","p":["O(n^2) runtime from the nested for loop, O(n^2) space for the 2D array"]},{"l":"4. Recovering the Matches","p":["So far our solution correctly computes the length, but we don’t know which characters are in the final LCS. More formally, how do we record the matching pair of indices i, j as the loops in the DP solution progresses?"]},{"l":"4.1 Recording the Choices","p":["We can use a technique called parent pointers. This technique will show up again in SSSP.","Recall from the recurrence that for all possible pairs of i,j, we always make a choice if we are not at the base case:","We can record the choices with a map, where the keys are the input parameters and the values are the choices:","We can add the choice-recording step:","Since we are iterating over all combinations of i and j, the lcsChoices map will have exactly m\\cdot n entries. Assuming we are not accounting for any additional memory overhead, the total space complexity remains O(mn)."]},{"l":"4.2 Following the parent pointers","p":["When we store the result lcsChoices[i, j] = [i + 1, j], we are saying that “the next best choice for \\text{LCS}(i,j) is (i+1, j)”.","The initial call for \\text{LCS} is i=1,j=1, so we start with this entry and follow the parent pointers until we hit the base case:","The while loop condition works because these loops from DP never go beyond m and n:","(m, n) will still be a key in lcsChoices, but none of its possible values, stored in lcsChoices[m, n], will be a key:","so we are guaranteed that this loop will stop."]},{"l":"Implementation Detail","p":["We are taking a shortcut here by assuming lcsChoices[i, j] is a valid key. This is valid in python because tuples are hash-able, but it might not be the case for other languages.","In that case we can always use a 2D array or a nested hash map and access by integer indices like lcsChoices[i][j]"]}],[{"l":"Maximum Sum After Partitioning","p":["Question. Given an array A[1...N] and a partition size k, 1 = k = N, partition the array into (contiguous) subarrays of length at most k. After partitioning, each subarray has their values changed to become the maximum value of that subarray. What is the largest sum of the given array after partitioning?"]},{"l":"Recurrence","p":["The final answer is PartitionSum(N). Visually, the recurrence describes the follows, (suppose j=3):","Adjust the indices with -1 offset when implementing this."]}],[{"l":"Pretty Printing","p":["Question. Given an array of N words and a maximum page width, what is the most optimal printing strategy that minimizes the total cost? Assume that any individual word can fit on one line.","the words we want to print neatly on a page","the maximum number of characters on a single line","a function that measures how \"bad\" a line is. The more empty spaces there are, the worse a line is. Let’s use x^3 here, where x is the number of trailing spaces.","We want to find:","a list of line break indices","the total cost after applying the line breaks","Depending on the variant of this question, sometimes the last line is free, which means we don’t calculate the cost of the final line.","To avoid weird indexing problems, let’s define a break at index i to mean putting \\tt words[i] on a new line."]},{"l":"1. Solve the Backtracking Problem"},{"l":"1.1 Function Signature & Base Case","p":["To keep track of how many words are remaining, we need an index j to indicate the last word that we need to place onto the paper. So the function looks like:","PrettyPrint(j: int) - int","and the initial call will be:","PrettyPrint(N)","There’s only 1 base case here: when there are no words, then there’s no cost, return 0.","PrettyPrint(0) = 0","In this case we are scanning from the last word to the first word, but reversing the scanning order also works. Flip the base case and initial call accordingly."]},{"l":"1.2 Line Cost","p":["From the problem inputs, we know that the cost of a line is given by:","Then number of empty spaces is:","num_empty_spaces = page_width - sentence_length","For the length of the sentence, we also need to count the number of spaces between the words.","Let’s define a function LineCost(i, j).","i is the index of the first word on this line","j is the index of the last word on this line","Both i and j are indices for the \\texttt{words} array","This is a bit different from the previous backtracking problems. We are incorporating the find valid choices step into this cost function by using \\infty as 1 of the costs.","To compute the number of empty spaces, lets define:","where i, j are the indices of the original words array. We can see that computing \\text{Extras} will take O(n) time where n is the number of words.","Now we can translate \\text{LineCost} into expressions:","So \\text{LineCost} also runs in O(n) time."]},{"l":"1.3 Recursive Cases","p":["This falls under the Best Solution case with the FindNext strategy, so we need:","Choices","Every index before the current index is a choice. We can place a line break at any of them.","The \"valid\" choice part is handled by the \\text{LineCost} function.","If the choice is not valid, \\text{LineCost} will return \\infty and it’s definitely not going to be selected.","How to make a choice","To make a choice, we go to the \"next\" word we want to place. We can either go from the end or go from the beginning.","If we go from the end j=n, the next one is j-1.","If we go from the beginning j=1, the next one is j+1.","Since we want to minimize the total cost, we will also need a min(...) call"]},{"l":"1.4 Recurrence & Pseudocode","p":["Combining 1.1 ~ 1.3, the recurrence is:","In expressions:","Convert to pseudocode:","Don’t forget i\\red{-1} in the recursive call, otherwise we will call PrettyPrint(j) again when i == j, which leads to infinite recursion."]},{"l":"1.5 Python. Backtracking Pretty Printing","p":["At each recursion level, we “choose” a line break","All indices before the current j is a “valid” choice","We take the min from all the choice results","Make sure you feel comfortable with the brute force solution before moving on to section 2."]},{"l":"2. Convert to Dynamic Programming"},{"l":"2.1 Order of Evaluation & Data Structure","p":["From the recurrence:","Unwrapping the \\min call shows that \\text{PrettyPrint}(j) needs: @Hint Plug in possible values of i.","We need to compute the function results of the smaller j’s first, thus the order of evaluation for j goes in ascending order.","The function only needs 1 parameter, so we can use a 1D array."]},{"l":"2.2 Pseudocode","p":["Time complexity is O(n^3) and space complexity is O(n).","If handling special indices like 0, -1 feels cumbersome, we can use a map."]},{"l":"❖ 3. Memoizing LineCost and Extras","p":["Calling LineCost inside nested for loops can be expensive, so we should isolate that from the main memoization loop. Since LineCost needs 2 parameters, we can use a 2D array to memoize the results. But directly going through all combinations of i, j doesn’t really help because that’s still O(n^3)","So we need to somehow use previous results to make the evaluation lineCost[i, j] O(1).","Observe that the actual work happens inside \\text{Extras}(i, j). Instead of recomputing the total number of characters every time we increase j, we can build on top of the previous result like this:","We can assume the \\text{len} function for finding the number of characters is O(1) because the work is done before the \\text{PrettyPrint} routine starts.","The base case is a single word:","Extras(i, i) = page_width - len(words[i])","\\text{Extras}(i, j) requires \\text{Extras}(i, j-1), so the order of evaluation goes in ascending order:","Now memoizing \\text{Extras} becomes O(n^2)."]},{"l":"4. Putting everything together","p":["The recurrences are:","Line cost itself isn’t really a recurrence but it’s important:","Runtime is O(n^2) with O(n^2) space."]},{"l":"5. Python: DP Pretty Printing"}],[{"l":"Levenshtein Edit Distance","p":["Question. Given 2 strings A[1...n] and B[1...m], what is minimum number of edits to A required to make 2 strings identical? An edit could be 1 of the following:","Insert a character","Delete a character","Replace a character","For example, when A = FOOD, B = MONEY, the edit distance is 4.","when A = HORSE, B = ROS, the edit distance is 3."]},{"l":"1. Observing the Problem","p":["From the example we can see that there are 3 operations at any given index i:","Insert(i) Cost = 1","Delete(i) Cost = 1","Replace(i, newChar) Cost = 1 if A[i] != B[i], else Cost = 0"]},{"l":"2. Solve the backtracking problem first"},{"l":"2.1 Decide the Function Signature","p":["Since we eventually need to convert this to DP, it’s easier to use string indices to keep track of which subproblem we are solving. Let’s use i for string A[1...n] and j for string B[1...n].","Our final result is:"]},{"l":"2.2 Base Cases","p":["If any of the string is empty, then the cost would be the length of that non-empty string. This will happen when we call:","Here we used 0 to indicate that an index is going out of bounds. In actual code 0 is a valid index; use -1 with an if statement to catch it."]},{"l":"2.3 Recursive Cases","p":["@EX A=\\texttt{\"FOOD\"}, B=\\texttt{\"MONEY\"}","+1 for the cost of deletion","+1 for the cost of insertion","But notice that the question mark technically doesn’t exist because A is shorter.","Delete","Delete is more straightforward. We simply don’t consider the i–th character in A.","If A[i] \\ne B[j] then the cost is 1","If A[i] = B[j] then the replacement is free","If both strings are not empty, we will try to insert, delete, or replace. These are the 3 possible choices. To make a choice:","If we insert a \\tt Y at the questions mark, we have an aligned column. Then we can move to the \"next\" by considering the column to the left.","Let’s consider what it really means to “insert”.","Maybe we can do this by i -= 1, j -= 1, now we are here:","Replace","Since we want the shortest distance, this falls under the best solution case and we will need a min(…) call.","So i is already at the position after insertion. All we need to do is move j to j-1.","Therefore the recursive call for delete is:","Therefore the recursive call for insert is:","Therefore the recursive call for replace is:","To find the cost, we check if the characters A[i] and B[j] are the same.","To replace a character, we move both i and j.","We can do this by moving i to i - 1."]},{"l":"2.4 Forming the recurrence","p":["Now we combine 2.2.2 and 2.2.3,","Convert to expressions:"]},{"l":"2.5 Python: Backtracking Edit Distance","p":["Implements the above recurrence.","We still make only 1 choice at each recursion level, the choices are:","Insert","Delete","Replace","All choices are valid when the 2 strings are not empty, so we try all 3 of them and see which one is the best.","Cost is always 1 for both insert and delete, 0 for replace if the characters are the same."]},{"l":"3. Convert Backtracking to Dynamic Programming"},{"l":"3.1 Data Structure","p":["The EditDistance(i, j) call requires 2 arguments, so we can use a 2D array.","EditDist: ListListint","We can access the result of a previous function call by EditDist[i, j]","The final result will be in EditDist[n, m]"]},{"l":"3.2 Order of Evaluation","p":["\\text{EditDist}(i, j) needs:","\\text{EditDist}(i, j - 1)","\\text{EditDist}(i-1, j)","\\text{EditDist}(i-1, j-1)","So both the loop for i and j need to go in ascending order.","Similar to LCS, if we scan the 2 strings backwards, then the order of evaluation will also be flipped. In that case i and j goes in descending order. The final call will be in EditDist[1, 1]"]},{"l":"4.2 Python: DP Edit Distance","p":["We can also save the recursion results by using the library @cache decorator. See LRU Cache.","This file has DP and @cache brute force."]}],[{"l":"Optimal Binary Search Tree","p":["Given a sorted list of search items A[1...n] and a frequency list f[1...n], where f[i] is the number of times we will search for element A[i]."]}],[{"l":"Chain Matrix Multiplication"}],[{"l":"Knapsack (Unique items)","p":["Given a single backpack with capacity C, a list of N items (can only take each item once) with weight w_i and value v_i, what combination of items that fits in the backpack will maximize the total value?","Let's first formalize what we want to maximize. Let the final selection of items be S,"]},{"l":"Base cases","p":["2 base cases:","No items: \\forall b, K(0, b) = 0","No capacity: \\forall i, K(i, 0) = 0"]},{"l":"Subproblems","p":["Recall that we want to consider some sort of \"prefix\" of the problem. Notice that we have this \"list\" of items, so we can label them arbitrarily from 1\\dots N. We can also put all capacities in a \"list\" from 0 to C. In this case we can consider the first i items out of all N and all weights in 0 \\dots C.","Let K(i, c) be the maximum value we can get from using items 1\\dots N with capacity c. which means the final answer is K(N, C)."]},{"l":"Take or Skip","p":["Now we have the subproblem, we want to try to take each item and see if it makes it better. Also don't forget that we can only take the item if it fits: w_i \\leq c","To \"take\" an item i, we decrease the capacity by its weight and move to the next item -> we will need the answer of K(i-1, c-w_i), then add the value of the item itself v_i","Note that we go to i-1 because we can only use up to item i, so we have to go to a lower index.","To \"skip\" item i, we just move the index: K(i-1, c)","Finally we take the better one:"]},{"l":"Pseudocode"},{"l":"Running time (NP Complete)","p":["This is just plain nested for loops so the runtime is O(NC).","Notice that N and C are not counting the same type of item. C can be way larger than N."]}],[{"l":"Knapsack (Unlimited supply)","p":["Given a single backpack with capacity C, a list of N items (they now have \\infty supply) with weight w_i and value v_i, what combination of items that fits in the backpack will maximize the total value?"]},{"l":"Base cases","p":["The same 2 base cases:","No items: \\forall b, K(0, b) = 0","No capacity: \\forall i, K(i, 0) = 0"]},{"l":"Basic DP solution","p":["The new take-or-skip is \"take another copy of item i or move to the next item\". To take another copy, we don't change i unlike the unique items variant:","To skip item i:","Then take the max:"]},{"l":"Simpler Subproblem","p":["Since the \"skip\" subproblem is just moving i to i-1, we can actually just keep track of the \"take\" subproblem:"]}],[{"l":"The Only Graph Traversal Algorithm","p":["Question. How to visit every vertex exactly once in a graph?"]},{"l":"Whatever First Search","p":["To keep track of which vertices we have seen, we use 2 STATUS values:","NEW: Never seen before.","SEEN: Processed exactly once.","Let T be the generic type name. We will make up an imaginary data structure called a BagT. It has 3 methods:","put(element: T) puts an element in the bag.","popFirst() - T returns whatever is the \"first\" thing in the bag and removes it.","isEmpty() - bool returns whether the bag is empty or not.","Then the pseudocode for whatever first search is:","Here process(u) is just a blackbox subroutine. We can do anything inside process(u) as long as we don’t change the vertex status."]},{"l":"Important Variants","p":["Best First Search","Breadth First Search","By changing the bag's behavior of popFirst() and put(element), we get the familiar search algorithms:","C++ also has std::dequeT","Depth First Search. DFS is usually implemented with recursion allowing cycle detection.","deque.pop() gives us DFS","deque.popleft() gives us BFS","For priority queue we could use heapq on a regular list [].","In python, we can easily swap between DFS and BFS by using collections.deque.","popFirst() pops from the end","popFirst() pops from the front","popFirst() pops the element with highest priority in O(\\log n) time.","put(element) appends to the end","put(element) appends with a priority value in O(\\log n) time","Use heappush and heappop to append and pop from the priority queue. See its use in Dijkstra's Algorithm.","We can represent NEW and SEEN with a set"]},{"l":"Python","p":["The WhateverFirstSearch_Connected function implements this.","This version of Whatever First Search assumes that the start can actually reach every other vertex in the graph. This works if we know the graph is connected.","To handle disconnected graphs we need to make the following modifications."]},{"l":"Whatever First Search–All","p":["For each vertex in G, if we’ve never visited this vertex before, visit everything that we can reach from this vertex.","We will make a small wrapper.","Changing the bag's behavior on popFirst() will result in the same variants, but now they can handle disconnected graphs."]},{"i":"python-1","l":"Python","p":["The WhateverFirstSearch_All function implements this."]}],[{"l":"Breadth First Search (122A)"},{"l":"Basics","p":["We can implement BFS from whatever first search by using a Queue.","The 122A version checks whether the adjacent vertex v is visited. The WFS version checks if the current vertex u is new."]},{"l":"Python"},{"l":"With time (full 122A Version)","p":["We can also record \"when\" a vertex is visited. Each time we see a new vertex, we increment the \"time\". The discover time of a vertex starts with \\infin."]},{"l":"Observing BFS’s Behavior / Level Order Traversal","p":["We can observe how each \"layer\" of the graph is being visited by BFS by adding a special token.","The changes are highlighted. Everything else is the same.","while queue has at least 1 vertex does not mean queue.size 0. The special token is not a vertex.","This is particularly useful if we are doing level-order traversal of a graph, because TOKEN marks the end of a level."]},{"i":"python-1","l":"Python"},{"l":"Examples"},{"l":"EX.1","p":["Given this graph, and we start at vertex \\tt{S}","Starting from \\tt S, we can see that all the red nodes \\tt{\\red{ACG}} are 1 edge away, and the purple nodes \\tt\\purple{BDEFH} are 2 edges away."]},{"l":"EX.2","p":["If we start at A, then the graph will be visited in this order: A - BCE - D. Vertices with the same color could be visited in any order depending on the order of insertion, but the overall order is Orange → Red → Purple."]}],[{"l":"Recursive Depth First Search (122A)"},{"l":"Vertex Status","p":["Similar to whatever first search, we assign each vertex a STATUS.","literally never seen before, all vertices start with this status","seen before, but the adjacent vertices are not done processing yet","the vertex is seen and all its children are done processing"]},{"l":"Pseudocode"},{"l":"Python: Basic DFS"},{"l":"Comparison with stack based Whatever First Search","p":["The recursive version replaces stack.put(v) with the recursive call DfsVisit(v).","while stack is not empty is the same as coming back to the initial call (empty call stack).","Every time DfsVisit(v) is called in the main routine, a new call stack is initialized. WFS does this by calling the stack constructor."]},{"l":"Runtime Analysis","p":["For a graph with V vertices and E edges, we call the DfsVisit(v) function V times in the main routine. The total number of recursive calls inside DfsVisit(v) is E times because we will traverse each edge exactly once, so E times for the entire graph.","Therefore the total runtime is O(V+E)."]},{"l":"Classifying Edges and Cycle Detection","p":["There are 4 possible types of edges:","More specifically:","Source: Prof Bai’s 122A slides. Gray = Active, White = New, Black = Finished"]},{"l":"Edge Interpretations","p":["At least one back edge is found \\iff the graph has a cycle. So Directed Acyclic Graphs (Like a DP dependency graph) cannot have a back edge.","Found at least 1 cross or forward edge \\implies the graph is directed","Read more here"]},{"l":"Python: DFS with edge classification","p":["Right now it only finds back and tree edges correctly, still figuring out how to find forward and cross edges"]}],[{"l":"Huffman Encoding"}],[{"l":"Scheduling Classes / Activity Selection (122A)","p":["Question. Given a list of class schedules consisting of start times S and end times F, what’s the maximum amount of classes we can take?","a map of start times of classes, where the key is the class name and the value is the start time.","a map of finish times of classes, where the key is the class name and the value is the finish time.","Constraint: All the times s[i] and f[i] are both less than some maximum time T.","We want to find Liststring, the longest list of classes we can take without schedule conflicts."]},{"l":"1. No Recursive Backtracking Here","p":["Well no but actually yes because this problem can be solved recursively.","We either take a class or skip. Since we want the maximum amount of classes, this problem falls under the best solution case.","Let curr be the current class we are considering and prev be the previous class we chose to take. The recurrence is:","Convert to expressions:","where curr.\\text{next} depends on the implementation to decide what the “next” class is.","This is the recurrence for computing the number of classes. Replace the +1 with the literal class name and replace 0 with empty array if we are finding the actual schedule."]},{"l":"1.1 Python. Scheduling with Backtracking","p":["This directly implements the recurrence above."]},{"l":"1.2 Python. Scheduling with DP","p":["Memoizes the recurrence."]},{"l":"2. Take the Local Best","p":["Backtracking takes O(2^n) with O(1) space, DP takes O(n^2) with O(n^2) space.","But we can do better. Since we want to take as many classes as possible, we want the current choice to be finish as early as possible to leave room for other classes. This is the greedy choice.","Then our local best is the class that finishes first, and is compatible with the previous choice.","If we use merge/quick sort, this algorithm is O(n\\log n + n) = O(n\\log n). Note that this greedy strategy won’t work if the classes are weighted."]},{"l":"2.1 Python. Greedy Scheduling"},{"l":"2.2 Proof. Greedy Exchange Argument","p":["Reference","Suppose there’s an optimal solution to the problem \\text{OPT}=\\{o_1 ,o_2, \\dots, o_k\\}. Then the maximum number of classes we can take is k. Now given a greedy solution A= \\{a_1, a_2, \\dots\\}, we can replace the first different choice of \\text{OPT} with a greedy choice and still remain optimal.","We are trying to show the new set A' is optimal:","|A'| = |\\text{OPT}|, so A' still has the maximum size","Every class in A' is compatible with each other","Now we show that the greedy choice is compatible. Assume without loss of generality that the first difference is the first choice ( i=1).","By greedy choice, f[a_1]\\leqslant f[o_1](Greedy stays ahead)","And we know f[o_1]\\leqslant s[o_2](from given, optimal solutions are always compatible)","Then f[a_1]\\leqslant s[o_2] by transitivity of \\leqslant.","Therefore a_1 is compatible with o_2, which means we can exchange a_1 with o_1 without making the solution worse. So \\text{OPT}-\\{o_1\\}+\\{a_1\\} is optimal. A is optimal by induction because we can swap everything inside \\text{OPT} with A."]}],[{"l":"Summary & Patterns"},{"l":"Finding the Greedy Solution","p":["Find the local best choice first, and keep making these choices if they are compatible with the previous ones."]},{"l":"Greedy strategies from the problems in this section","p":["Problem","Local Best is...","Compatible if...","Activity Selection","the class that ends the earliest","the class doesn't conflict with existing schedule","Driving Problem","the farthest gas station","the station is within our range"]},{"l":"The Greedy Exchange Argument","p":["Show that there’s an arbitrary optimal solution \\text{OPT} different from greedy solution A.","Find the “first difference” between \\text{OPT} and A.","For a more rigorous proof, you also need to show that this difference actually exists","Argue that exchanging this optimal choice with a greedy choice will NOT make the solution worse. Doesn’t have to make it better.","Use induction to show that the entirety of \\text{OPT} can be swapped with A","This step is technically implicit from step 2, but it depends."]}],[{"l":"Pseudocode Syntax Reference"},{"l":"Basics","p":["Math operators are used the same as they are in formal mathematical writing.","- indicates a return type. Only used for function declarations.","If nothing is returned, this symbol is unused.","Any kind of indexing, range, interval is inclusive and 1-based unless explicitly stated.","Example: A[1...N]: Listnumber means the list A has N elements and can be indexed by 1, 2, 3, ... N.","Angle brackets T indicate the use of type parameters. For example, ListVertex means elements of this list are vertices."]},{"l":"Examples","p":["In this pseudocode:","Array A can be indexed by integers in [1, n]","mid was declared and assigned the value floor(n / 2)","floor, Merge are function calls","Returns nothing","Here we have an global constant prices = [...]. The function returns a number. int or float are explicitly stated when it is important (e.g. if the function returns an index, it must be an int)."]},{"l":"Data Structure Initialization","p":["Any object will be created on the heap through its constructor and are passed around by reference. (anything other than numbers, booleans, and strings)"]},{"l":"Multi-dimensional Arrays","p":["Let’s use this syntax to state each dimension's size of the array:","For example:","This means B can be indexed by:","1 through 5 on the 1st axis","1 through 6 on the 2nd axis."]}]]